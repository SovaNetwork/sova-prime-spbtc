import { NextRequest, NextResponse } from 'next/server';
import { rateLimit, getRateLimitType, RATE_LIMIT_CONFIGS } from './lib/rateLimit';

export async function middleware(request: NextRequest) {
  // Only apply rate limiting to API routes
  if (!request.nextUrl.pathname.startsWith('/api')) {
    return NextResponse.next();
  }

  // Skip rate limiting for health check or internal routes
  if (request.nextUrl.pathname === '/api/health' || 
      request.nextUrl.pathname.startsWith('/api/_')) {
    return NextResponse.next();
  }

  try {
    // Determine the appropriate rate limit type
    const limitType = getRateLimitType(request.nextUrl.pathname, request.method);
    
    // Apply rate limiting
    const result = await rateLimit(request, limitType);

    if (!result.success) {
      const headers = new Headers({
        'X-RateLimit-Limit': RATE_LIMIT_CONFIGS[limitType].maxRequests.toString(),
        'X-RateLimit-Remaining': '0',
        'X-RateLimit-Reset': Math.ceil(result.reset / 1000).toString(),
        'Retry-After': Math.ceil((result.reset - Date.now()) / 1000).toString(),
        'Content-Type': 'application/json'
      });

      if (result.blocked && result.blockUntil) {
        headers.set('X-RateLimit-Blocked-Until', Math.ceil(result.blockUntil / 1000).toString());
        
        return new NextResponse(
          JSON.stringify({
            error: 'Rate limit exceeded - temporarily blocked',
            message: `Too many requests. Blocked until ${new Date(result.blockUntil).toISOString()}`,
            blockedUntil: new Date(result.blockUntil).toISOString(),
            retryAfter: Math.ceil((result.blockUntil - Date.now()) / 1000)
          }),
          { status: 429, headers }
        );
      }

      return new NextResponse(
        JSON.stringify({
          error: 'Rate limit exceeded',
          message: `Too many requests. Try again in ${Math.ceil((result.reset - Date.now()) / 1000)} seconds.`,
          retryAfter: Math.ceil((result.reset - Date.now()) / 1000)
        }),
        { status: 429, headers }
      );
    }

    // Continue to the API route with rate limit headers
    const response = NextResponse.next();
    response.headers.set('X-RateLimit-Limit', RATE_LIMIT_CONFIGS[limitType].maxRequests.toString());
    response.headers.set('X-RateLimit-Remaining', result.remaining.toString());
    response.headers.set('X-RateLimit-Reset', Math.ceil(result.reset / 1000).toString());

    return response;

  } catch (error) {
    console.error('Rate limiting middleware error:', error);
    // If rate limiting fails, allow the request through
    return NextResponse.next();
  }
}

export const config = {
  matcher: [
    /*
     * Match all API routes except:
     * - Health check endpoint
     * - Internal Next.js routes (starting with _)
     */
    '/api/((?!health|_).*)',
  ],
};